{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Frigate","text":"<p>Frigate is a lightweight web application framework. It is designed to be easy, and extremely fast with the ability to scale up to complex applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Easy and Powerfull routing system.</li> <li>Builtin Database class for MySQL.</li> <li>Build an API</li> <li>Serve Files, Pages, JSON.</li> <li>Build Hybrid application (e.g an API with a administration panel).</li> <li>PHP - 8.</li> <li>Easy framework syntax.</li> <li>Very Flexible design.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install Frigate with composer:</p> <pre><code>composer require siktec/frigate\n</code></pre> <p>Use a bootstrap project to get started:</p> <pre><code>composer create-project siktec/frigate-bootstrap\n</code></pre>"},{"location":"Documentation/frigate-app/","title":"Frigate Application","text":"<p>At the heart of every Frigate application is the Frigate application instance. The application instance is a static class that is responsible for bootstrapping the application, to normalize and make several features available to the entire Frigate application.</p> <p>The application instance is responsible for:</p> <ul> <li>Parsing environment variables and making them available to the application.</li> <li>Defining some default global constants.</li> <li>Adjusting the php configuration for the runtime environment (if needed).</li> <li>Starting a session (if needed).</li> </ul> <p>While its possible to use Frigate without initializing the application instance, it is recommended to initialize the application instance as soon as possible. The application instance is initialized by calling the <code>init</code> method:</p> <pre><code>&lt;?php\n\n// index.php\n\n// ... other code\n\nuse Frigate\\FrigateApp as App;\n\n// Initialize the application instance.\nApp::init(\n    root              : __DIR__, // will set the root folder of the application. (string)\n    env               : null,   // will load the environment variables from the .env file default is null. (array|string|null)\n    extra_env         : [],     // will add additional environment variables to the application. (array)\n    start_session     : true,   // will start the session if needed. (bool) default is true. \n    start_page_buffer : true,   // will start the page buffer if needed. (bool) default is true.\n    adjust_ini        : true    // will adjust the php configuration if needed. (bool) default is true\n);\n\n// ... other code\n</code></pre> <p>Once the application instance is initialized accross the application we can access the application instance using the <code>FrigateApp</code> class To access different features of the application instance.</p>"},{"location":"Documentation/frigate-app/#environment-variables","title":"Environment variables","text":"<p>Each Frigate application has a set of environment variables that are used to configure the application. Those are required for the application to work correctly and are loaded from the <code>.env</code> file by default.</p> <ol> <li> <p>Load the environment variables from root folder <code>.env</code> file:     <pre><code>&lt;?php\n\nuse Frigate\\FrigateApp as App;\n// will load the environment variables from the .env file.\nApp::init( root : __DIR__, /* env: null */ ); // env is null by default. root will be used as the root folder.\n</code></pre></p> </li> <li> <p>Load the environment variables from a specific file:     <pre><code>&lt;?php\n\nuse Frigate\\FrigateApp as App;\n// will load the environment variables from the .env file.\nApp::init(\n    root : __DIR__,\n    env: [  __DIR__ . \"/config/\", \".env.local\" ] // will load the .env and .env.local files from the config folder.\n);\n</code></pre></p> </li> <li>Load the environment variables from several files.     <pre><code>&lt;?php\n\nuse Frigate\\FrigateApp as App;\n// will load the environment variables from the .env file.\nApp::init(\n    root : __DIR__,\n    env: [ \n        [ __DIR__ . \"/config/\" ], // Directories to look in.\n        [ \".env\", \".env.local\" ]  // files to load.\n    ]\n);\n</code></pre></li> <li>Load the environment variables from an array.     <pre><code>&lt;?php\n\nuse Frigate\\FrigateApp as App;\n// will load the environment variables from the .env file and add the additional environment variables.\nApp::init(\n    root : __DIR__,\n    env: __DIR__,\n    extra_env: [\n        \"MY_ENV_VAR\" =&gt; \"my value\"\n    ]\n);\n</code></pre></li> </ol>"},{"location":"Documentation/frigate-app/#required-env-variables","title":"Required Env variables","text":"<ul> <li> <p><code>FRIGATE_ROOT_FOLDER</code> string - the root folder of the application. empty string by default ('/'). (1)</p> <ol> <li>The root folder is the folder that contains the <code>index.php</code> in relation to the web root folder.</li> </ol> </li> <li> <p><code>FRIGATE_BASE_URL</code> string - the base URL of the application. e.g. <code>\"http://example.com/\"</code>. (1)</p> <ol> <li>The base URL is used to generate the URLs of the application. the base URL should not include the URI path.  for example, if the application is located at <code>http://example.com/my-app/</code> the base URL should be <code>http://example.com/</code> and the root folder should be <code>my-app</code>. </li> </ol> </li> <li> <p><code>FRIGATE_APP_VERSION</code> string - the version of YOUR application.</p> </li> <li><code>FRIGATE_DEBUG_ROUTER</code> boolean - enable debug mode for the router.</li> <li><code>FRIGATE_DEBUG_ENDPOINTS</code> boolean - enable debug mode for the endpoints.</li> <li><code>FRIGATE_DEBUG_TO_FILE</code> boolean - enable debug mode for the endpoints.</li> <li> <p><code>FRIGATE_DEBUG_FILE_PATH</code> string - the path to the debug log file. (1)</p> <ol> <li>The debug log file will contain all debug messages from the router and the endpoints.</li> </ol> </li> <li> <p><code>FRIGATE_EXPOSE_ERRORS</code> boolean - enable error reporting will expose errors to the client.</p> </li> <li><code>FRIGATE_ERRORS_TO_FILE</code> boolean - enable error reporting will log errors to the file.</li> <li> <p><code>FRIGATE_ERRORS_FILE_PATH</code> string - the path to the error log file. (1)</p> <ol> <li>The error log file will contain all errors from the router and the endpoints.</li> </ol> </li> </ul> Will throw an exception if not defined <p>The application will throw an exception if any of the required environment variables are not defined. or are not valid. This also applies to your own environment variables which are defined by extending the <code>FrigateApp</code> class.</p>"},{"location":"Documentation/frigate-app/#using-env-variables","title":"Using Env variables","text":"<p>After initializing the application instance, all environment variables are available in <code>$_ENV</code> and <code>$_SERVER</code> super globals. For a convenient way to access the environment variables, the application instance provides some helper methods that serialize the environment variables into a specific type.</p> <pre><code>&lt;?php\n\n// ... other code\n\nuse Frigate\\FrigateApp as App;\n\nApp::init( root: __DIR__ );\n\n$root_folder = App::ENV_STR(\"FRIGATE_ROOT_FOLDER\");\n$debug_router = App::ENV_BOOL(\"FRIGATE_DEBUG_ROUTER\");\n$debug_endpoints = App::ENV_BOOL(\"FRIGATE_DEBUG_ENDPOINTS\");\n\n// Assuming the following optional environment variables are defined and are OPTIONAL:\n// MY_ENV_NUMBER = 123\n// MY_ENV_FLOAT = 123.456\n$my_env_number = App::ENV_INT(\"MY_ENV_NUMBER\", 0); // 123 or 0 if not defined.\n$my_env_float = App::ENV_FLOAT(\"MY_ENV_FLOAT\", 0.0); // 123.456 or 0.0 if not defined.\n\n// ... other code\n</code></pre> <p>More about environment variables</p> <ol> <li>All environment are uppercased.</li> <li>All Frigate environment variables are prefixed with <code>FRIGATE_</code>.</li> <li>All <code>ENV_*</code> methods are case insensitive and return the <code>null</code> value if the environment variable is not defined by default.</li> </ol>"},{"location":"Documentation/frigate-app/#custom-env-variables","title":"Custom Env variables","text":"<p>You can leverage the environment variables functionality to define your own environment REQUIRED variables. This is useful if you want to define some configuration variables for your application and properly handle them and validate them.</p> <p>This can be achieved in to ways:</p> <ol> <li> <p>Extending the <code>FrigateApp</code> class and define the <code>application_env</code> array.     <pre><code>&lt;?php\n    // MyApplication.php\n    use Frigate\\FrigateApp as App;\n\n    // Extend the FrigateApp class.\n    class MyApplication extends App {\n        public static array $application_env = [\n            \"MY_ENV_VAR\"    =&gt; \"not-empty\",\n            \"MY_ENV_VAR2\"   =&gt; \"string\",\n            \"MY_ENV_VAR3\"   =&gt; \"int\",\n            \"MY_ENV_VAR4\"   =&gt; \"bool\"\n        ];\n    }\n\n    // index.php\n    use MyApplication as App;\n\n    App::init( root: __DIR__ ); // All New environment variables will be required and validated.\n</code></pre></p> </li> <li> <p>Adding the environment variables to the <code>application_env</code> array of the application instance.     <pre><code>&lt;?php\n\n    // index.php\n    use Frigate\\FrigateApp as App;\n\n    App::$application_env = [\n        \"MY_ENV_VAR\"    =&gt; \"not-empty\",\n        \"MY_ENV_VAR2\"   =&gt; \"string\",\n        \"MY_ENV_VAR3\"   =&gt; \"int\",\n        \"MY_ENV_VAR4\"   =&gt; \"bool\"\n    ];\n\n    App::init( root: __DIR__ ); // All New environment variables will be required and validated.\n</code></pre></p> </li> </ol> You don't need that for your optional environment variables <p>You don't need to define your optional environment variables in the <code>application_env</code> array. You can simply use the <code>ENV_*</code> methods and provide a default value. Any environment that is defined in the <code>.env</code> file will be available in the <code>$_ENV</code> and <code>$_SERVER</code> super globals.</p>"},{"location":"Documentation/frigate-app/#frigate-constants","title":"Frigate Constants","text":"<p>After initializing the application instance, several constants are defined by the application instance and are available throughout the application. The constants are used around the application to make it easier to access some of the application configuration and paths. and are heavily used by Frigate core.</p> Constant Example Description <code>APP_ROOT</code> <code>/var/www/html/website</code> The full path to the root folder of the application without the trailing slash. <code>APP_VENDOR</code> <code>/var/www/html/website/vendor</code> The vendor folder of the application. without the trailing slash. <code>APP_BASE_PATH</code> <code>/website</code> The base path of the application. which is the URI path of the application in relation to the web root folder. <code>APP_BASE_URI</code> <code>/website</code> The base URI of the application. same as <code>APP_BASE_PATH</code> but with url encoding. without the trailing slash. <code>APP_BASE_URL</code> <code>http://example.com</code> The base URL of the application. without the trailing slash. <code>APP_VERSION</code> <code>1.2.45</code> The version of the application. <code>APP_LOG_ERRORS</code> <code>true</code> Whether errors are logged to file or not. <code>APP_EXPOSE_ERRORS</code> <code>true</code> Whether errors are exposed to the client or not. <p>Overriding the constants</p> <p>The constants are defined by the application instance after it is initialized. You can override the constants by defining them before initializing the application instance. This is useful if you want to quickly change ERROR logging for example. That said, it is recommended to use the environment variables to configure the application.</p>"},{"location":"Documentation/frigate-app/#php-configuration","title":"PHP Configuration","text":""},{"location":"Documentation/frigate-app/#session","title":"Session","text":""},{"location":"Documentation/frigate-app/#page-buffer","title":"Page Buffer","text":""},{"location":"Documentation/middleware/","title":"Middleware","text":""},{"location":"Documentation/middleware/#initialize-the-router","title":"Initialize the router","text":"<p>After the frigate <code>FrigateApp</code> has been initialized, the router can be initialized. The router is initialized with the <code>init</code> method. The <code>init</code> method takes: - <code>debug</code> - a boolean value to enable debug mode for the router.</p> <pre><code>&lt;?php\n\n// We use the Frigate Base class to help with environment variables.\n// This is not required but it is recommended.\nRouter::init(\n    load_request : true, // (bool) Load the request immediately. Default is true.\n    debug        : null, // (null|bool) Enable debug mode. Default is null which will use the environment variable.\n    use_request  : null, // (null|string) Use a specific request object. Default is null which will use the default request object.\n    use_response : null, // (null|string) Use a specific response object. Default is null which will use the default response object.\n);\n\n// If the request is not loaded immediately we can load it later:\nRouter::loadRequest();\n</code></pre> <p>The router is now initialized and ready to define routes. The router parses the request and matches it against the defined routes. After the execution of the route, the response is sent to the client.</p>"},{"location":"Documentation/middleware/#defining-routes","title":"Defining Routes","text":"<p>Routes are defined using the <code>define</code> method. The <code>define</code> method takes: - <code>method</code> - the HTTP method of the route. This can be a string or an array of strings. - <code>route</code> - the <code>Route</code> object that defines the route logic.</p> <pre><code>&lt;?php\n\n    // index.php file\n    // ..... Initialize the App and Router\n\n    use Frigate\\Routing\\Http\\Methods;\n    use Frigate\\Routing\\Routes\\Route;\n\n    /* \n        Define a route - In this case a GET route that matches the path \"/me/{some_name}\"\"\n        and executes the MyEndpoint class.\n    */\n    Router::define(Methods::GET, new Route(\n        path: \"/me/?{name}\",    // The path of the route.\n        context: [              // The context that will be passed to the endpoint.\n            \"name\" =&gt; \"John\"    // The default value of the name parameter.\n        ],\n        exp: new MyEndpoint( debug: null ), // The endpoint class this route will execute.\n        returns: [\"application/json\"],      // The supported return types.\n        middleware: [],        // Additional middleware to execute before the route.\n        avoid_middleware: [],  // Middlewares to avoid.\n        request_mutator: null   // The request mutator.\n    ));\n\n    // ..... Run the router\n</code></pre> <p>This is the most basic way to define a route. The route will match the path <code>/me/</code> and <code>/me/John</code> etc... and will execute the <code>MyEndpoint</code> class which is a class that extends the <code>Endpoint</code> class - about endpoints.</p>"},{"location":"Documentation/middleware/#generic-routes","title":"Generic Routes","text":"<p>For convenience, the <code>Router</code> class has dome predefined methods for the most common HTTP methods and for the most common route types. These methods are:</p> <ul> <li><code>get</code> - defines a GET route.</li> <li><code>post</code> - defines a POST route.</li> <li><code>put</code> - defines a PUT route.</li> <li><code>patch</code> - defines a PATCH route.</li> <li><code>delete</code> - defines a DELETE route.</li> <li><code>options</code> - defines an OPTIONS route.</li> <li><code>head</code> - defines a HEAD route.</li> <li><code>any</code> - defines a route that matches any HTTP method.</li> <li><code>static</code> - defines a static route that serves a file.</li> <li><code>error</code> - defines an error route that will be executed when an error occurs.</li> </ul> <p>For all the generic routes and the <code>any</code> route you can simply use them as a method of the <code>Router</code> class. For example:</p> <pre><code>&lt;?php\n\n    // index.php file\n\n    // ..... Initialize the App and Router\n\n    Router::get( // Or any other method like post, put, patch, delete, options, head, any\n        path : \"/me/?{name}\",\n        context: [\n            \"name\" =&gt; \"John\"\n        ],\n        exp  : new MyEndpoint( debug: null)\n    );\n</code></pre> <p>This is the same as the previous example but with a more convenient way to define the route.</p> <p><code>static</code> and <code>error</code> routes are special routes that have predefined behavior. The <code>static</code> route will serve a file from the file system and the <code>error</code> route will be executed when an error occurs. The <code>error</code> route is described in the error handling section.</p>"},{"location":"Documentation/middleware/#static-routes","title":"Static Routes","text":"<p>Static routes are routes that serve files from the file system. The <code>static</code> route is defined with the <code>static</code> method of the <code>Router</code> class. The <code>static</code> method takes: - <code>path</code> - (string) the path of the route - using the path syntax described below. - <code>directory</code> - (string) the absolute path to the directory that contains the files. - <code>types</code> - (string|array) the file types that will be served. This can be a string or an array of strings. The default is <code>[\"*/*\"]</code> which will serve all files.</p> <p>Here is an example of a static route:</p> <pre><code>&lt;?php\n    // index.php file\n\n    // ..... Initialize the App and Router\n\n    Router::static(\n        path        : \"/storage\", // The path of the route.\n        directory   : __DIR__ . DIRECTORY_SEPARATOR . \"files\", // The directory that contains the files. \n        types       : [\"image/*\", \"text/*\", \"video/*\"] // The types of files that will be served.\n    );\n</code></pre> <p>This will serve files from the <code>files</code> directory when the path <code>/storage/...</code> is requested. The files will be served with the correct mime type based on the file extension.</p> How do I set the file disposition? <p>By default, the file disposition is set to <code>inline</code>. This means that the file will be displayed in the browser. Which means that if the browser can display the file it will. If you want to force the download of the file you can set the file disposition to <code>attachment</code>. This can be done by passing the <code>types</code> parameter as an associative array where the key is the mime type and the value is the file disposition. For example:</p> <pre><code>&lt;?php\n   // ....\n   types : [\n       \"image/*\" =&gt; \"inline\",\n       \"text/*\"  =&gt; \"attachment\",\n       \"video/*\" =&gt; \"inline\"\n   ]\n   // ....\n</code></pre> <p>Note</p> <ol> <li>You can use the path syntax described below to define the path of the static route. But the path should not contain <code>path parameters</code>.</li> <li>All the logic of the static route is handled by a custom handler that is provided by Frigate. This <code>Endpoint</code> is called <code>StaticEndpoint</code> and is described in the endpoints section.</li> </ol>"},{"location":"Documentation/middleware/#auto-loading-routes","title":"Auto loading routes","text":"<p>When the application grows, the number of routes will grow as well. To make the code more readable and maintainable, the routes can be defined in separate files and auto-loaded by the router. This can be done by defining the routes in a separate file and then loading the file with the <code>defineFrom</code> method of the <code>Router</code> class. The <code>defineFrom</code> method takes: - <code>path</code> - (string) the path to the folder that contains the route files.</p> <p>Each route file should define a single class that extends the <code>DefineRoute</code> class. The class should have a single constructor that takes no arguments and should define the routes in the constructor. </p> <p>Here is an example of a route file:</p> <pre><code>&lt;?php\n\n// MyNameRoute.php file in the routes folder - /routes/MyNameRoute.php\n\nuse Frigate\\Routing\\Routes\\DefineRoute;\nuse Frigate\\Routing\\Http\\Methods;\nuse Frigate\\Routing\\Http\\ResponseInterface;\nuse Frigate\\Routing\\Http\\RequestInterface;\n\nclass MyNameRoute extends DefineRoute\n{\n    public function __construct()\n    {\n        // Define the route method(s):\n        $this-&gt;method = [Methods::GET, Methods::POST];\n\n        // Define the route path:\n        $this-&gt;path = \"/say/?{name:string}\";\n\n        // Define the route context:\n        $this-&gt;context = [\n            \"name\" =&gt; \"John Doe\"\n        ];\n\n        // Define the supported return types:\n        $this-&gt;returns = [\n            \"application/json\"\n        ];\n\n        // Bind the route endpoint or expression:\n        $this-&gt;exp = function(array $context, RequestInterface $request, ResponseInterface $response) {\n            // Set the response data:\n            $response-&gt;setBodyJson([\n                \"message\"   =&gt; \"success\",\n                \"name\"      =&gt; $context[\"name\"],\n                \"context\"   =&gt; $context\n            ]);\n            // return the response:\n            return $response;\n        };\n\n        // Define the route additional middleware:\n        $this-&gt;middleware = [];\n\n        // Define the route middleware to avoid:\n        $this-&gt;avoid_middleware = [];\n\n        // Define the request mutator:\n        $this-&gt;request_mutator = null;\n    }\n}\n</code></pre> <p>Note</p> <ol> <li>The class name should be the same as the file name without the <code>.php</code> extension.</li> </ol> <p>This is how all the route files inside the routes will be auto-loaded by the router:</p> <pre><code>&lt;?php\n\n// index.php file\n\n// ..... Initialize the App and Router\n\nRouter::defineFrom(\"routes\"); // The path is relative so for a full path use __DIR__ . DIRECTORY_SEPARATOR . \"routes\"\n\n// After this line all the routes defined in the routes folder will be loaded an registered with the router.\n</code></pre>"},{"location":"Documentation/middleware/#path-syntax","title":"Path Syntax","text":"<p>The route path is the URI that the router will match against. The route path can contain path parameters, and path parameters can have a type:</p> <ul> <li><code>\"/\"</code> - will match the root path.</li> <li><code>\"users\"</code> - will match the path \"/users\"</li> <li><code>\"users/{id}\"</code> - will match the path \"/users/1\" and \"/users/2\" etc...</li> <li><code>\"users/{id:int}\"</code> - will match the path \"/users/1\" and \"/users/2\" and will place the id in the context as an integer.</li> </ul> <p>Note</p> <ol> <li>The path is case insensitive. This means that the path <code>/users</code> will match <code>/Users</code> and <code>/USERS</code> etc...</li> <li>When defining the same path with the same method twice, the last definition will override the previous one.</li> </ol>"},{"location":"Documentation/middleware/#path-parameters","title":"Path parameters","text":"<p>Path parameters are defined by wrapping the parameter name with curly brackets <code>{}</code>. The parameter name can be any alphanumeric string and can contain underscores <code>_</code>. It is recommended to use a descriptive name.</p> <p>The parameter name can also contain a type. The type is used to convert the path parameter to a specific type in the context.</p> <ul> <li><code>int, integer</code> - will convert to an integer.</li> <li><code>float, double</code> - will convert to a float.</li> <li> <p><code>bool, boolean</code> - will convert to a boolean. (1)</p> <ol> <li>The boolean type will convert the following values to true: <code>1, true, on, yes</code> and the following values to false: <code>0, false, off, no</code>.</li> </ol> </li> <li> <p><code>string, str</code> - will match any string. Which is the default type.</p> </li> <li><code>path</code> - will be a string containing the rest of the path.</li> </ul> <p>The way we define the type is by adding a colon <code>:</code> after the parameter name and then the type name:</p> <ul> <li><code>\"users/{id:int}\"</code> - id will be an <code>int</code>.</li> <li><code>\"users/{height:float}\"</code> - height will be a <code>float</code>.</li> <li><code>\"users/{is_active:bool}\"</code> - is_active will be a <code>bool</code>.</li> <li><code>\"users/{name}\"</code> - name will be a <code>string</code>.</li> <li><code>\"users/{name:string}/{id:int}/{action}\"</code> - we can mix types and non types.</li> <li><code>\"users/{storage:path}\"</code> - storage will be a <code>string</code> containing the rest of the path.</li> </ul> Exceptions and limitations <ol> <li>An exception will be thrown if the several path parameters are defined on the same level.<ul> <li>i.e. defining <code>\"users/{id:int}\"</code> and <code>\"users/{name:string}\"</code> will throw an exception.</li> </ul> </li> <li>The <code>path</code> parameter cannot be extended with other parameters.<ul> <li>i.e. <code>\"users/{storage:path}/{id:int}\"</code> will throw an exception.</li> </ul> </li> </ol>"},{"location":"Documentation/middleware/#variation-macro","title":"Variation Macro","text":"<p>In Frigate we can define multiple levels of a path with the variation macro <code>?</code>. The variation macro will expand to a several paths:</p> <ul> <li><code>\"users/storage/?{find}/?{term}\"</code> - will expand to:<ul> <li><code>\"users/storage/\"</code></li> <li><code>\"users/storage/{find}/\"</code></li> <li><code>\"users/storage/{find}/{term}\"</code></li> </ul> </li> </ul> <p>Obviously, this can be done manually but it is a lot easier to use the variation macro. Also, the variation macro can be used to mimic default values in path parameters. For example:</p> <pre><code>&lt;?php\n// ...\n\nRouter::define(Methods::GET, new Route(\"users/storage/?find/?{term}\",\n    context : [\n        \"find\" =&gt; \"all\",\n        \"term\" =&gt; \"avatar.png\",\n    ],\n    // ... rest of the route definition\n));\n</code></pre> <p>All the expanded paths will be matched and the context will be merged with the context defined in the route definition. This behavior will result in 3 paths that points to the same route and have \"default\" values for the <code>find</code> and <code>term</code> parameters.</p> <ul> <li><code>\"users/storage/\"</code> - will have the context: <code>[\"find\" =&gt; \"all\", \"term\" =&gt; \"avatar.png\"]</code></li> <li><code>\"users/storage/picture/\"</code> - will have the context: <code>[\"find\" =&gt; \"picture\", \"term\" =&gt; \"avatar.png\"]</code></li> <li><code>\"users/storage/picture/profie.png\"</code> - will have the context: <code>[\"find\" =&gt; \"picture\", \"term\" =&gt; \"profie.png\"]</code></li> </ul>"},{"location":"Documentation/middleware/#default-parameter-values","title":"Default parameter values","text":"<p>Default values are not supported in path parameters. They don't make sense in the context of a path parameter. Some frameworks support default values (sort of) by looking ahead in the path and matching the next path part. This is not supported in Frigate.</p> <p>The best way to handle this is to define several paths that point to the same route and have different levels of path parameters. This can be done easily with the variation macro <code>?</code> as described above.</p> Why not??? <p>The reason for this is that it is not clear what the default value should be. For example, if we have the following path: <code>\"users/{id:int}/{action}\"</code> and we want to set the default value of <code>action</code> to <code>view</code>. What should happen if the path is <code>/users/1</code>? Should the default value be set to <code>view</code> or should the path not match? This is not clear and can lead to unexpected behavior.</p>"},{"location":"Documentation/middleware/#shadow-path-markers","title":"Shadow path markers","text":"<p>In Frigate shadow paths are defined by adding a <code>^</code> after the path. Internally, the shadow path marker is used to attach expressions that will be executed when the this marker is reached. For example:</p> <ul> <li><code>\"/users^\"</code> - a any path that starts with <code>/users</code> will invoke the attached expressions before the route is executed.</li> <li><code>\"/users^/{id:int}\"</code> - when executing the route <code>/users/1</code> the attached expressions will be executed before the route is executed, passing the modified context to the route.</li> <li><code>\"/users^/{id:int}^/profile\"</code> - shadow paths can be chained together. when executing the route <code>/users/1/profile</code> the shadow expressions will be executed twice, once for <code>/users/1</code> and once for <code>/users/1/profile</code>.</li> </ul> <p>This mechanism is used to attach middleware to a route. and is described in the middleware section.</p> <p>Note</p> <p>The shadow path marker is not part of the path and will not be matched. It is used to attach expressions to the path.</p> <p>Warning</p> <p>Don't use the shadow path marker unless you know what you are doing. Frigate offers a better way to attach middleware to a route. See the middleware section.</p>"},{"location":"Documentation/quick-start/","title":"Quick Start","text":"<p>Did you install Frigate?</p> <p>If you haven't installed Frigate yet, please read the Installation guide.</p>"},{"location":"Documentation/routing/","title":"Routing","text":""},{"location":"Documentation/routing/#initialize-the-router","title":"Initialize the router","text":"<p>After the frigate <code>FrigateApp</code> has been initialized, the router can be initialized. The router is initialized with the <code>init</code> method. The <code>init</code> method takes: - <code>debug</code> - a boolean value to enable debug mode for the router.</p> <pre><code>&lt;?php\n\n// We use the Frigate Base class to help with environment variables.\n// This is not required but it is recommended.\nRouter::init(\n    load_request : true, // (bool) Load the request immediately. Default is true.\n    debug        : null, // (null|bool) Enable debug mode. Default is null which will use the environment variable.\n    use_request  : null, // (null|string) Use a specific request object. Default is null which will use the default request object.\n    use_response : null, // (null|string) Use a specific response object. Default is null which will use the default response object.\n);\n\n// If the request is not loaded immediately we can load it later:\nRouter::loadRequest();\n</code></pre> <p>The router is now initialized and ready to define routes. The router parses the request and matches it against the defined routes. After the execution of the route, the response is sent to the client.</p>"},{"location":"Documentation/routing/#defining-routes","title":"Defining Routes","text":"<p>Routes are defined using the <code>define</code> method. The <code>define</code> method takes: - <code>method</code> - the HTTP method of the route. This can be a string or an array of strings. - <code>route</code> - the <code>Route</code> object that defines the route logic.</p> <pre><code>&lt;?php\n\n    // index.php file\n    // ..... Initialize the App and Router\n\n    use Frigate\\Routing\\Http\\Methods;\n    use Frigate\\Routing\\Routes\\Route;\n\n    /* \n        Define a route - In this case a GET route that matches the path \"/me/{some_name}\"\"\n        and executes the MyEndpoint class.\n    */\n    Router::define(Methods::GET, new Route(\n        path: \"/me/?{name}\",    // The path of the route.\n        context: [              // The context that will be passed to the endpoint.\n            \"name\" =&gt; \"John\"    // The default value of the name parameter.\n        ],\n        exp: new MyEndpoint( debug: null ), // The endpoint class this route will execute.\n        returns: [\"application/json\"],      // The supported return types.\n        middleware: [],        // Additional middleware to execute before the route.\n        avoid_middleware: [],  // Middlewares to avoid.\n        request_mutator: null   // The request mutator.\n    ));\n\n    // ..... Run the router\n</code></pre> <p>This is the most basic way to define a route. The route will match the path <code>/me/</code> and <code>/me/John</code> etc... and will execute the <code>MyEndpoint</code> class which is a class that extends the <code>Endpoint</code> class - about endpoints.</p>"},{"location":"Documentation/routing/#generic-routes","title":"Generic Routes","text":"<p>For convenience, the <code>Router</code> class has dome predefined methods for the most common HTTP methods and for the most common route types. These methods are:</p> <ul> <li><code>get</code> - defines a GET route.</li> <li><code>post</code> - defines a POST route.</li> <li><code>put</code> - defines a PUT route.</li> <li><code>patch</code> - defines a PATCH route.</li> <li><code>delete</code> - defines a DELETE route.</li> <li><code>options</code> - defines an OPTIONS route.</li> <li><code>head</code> - defines a HEAD route.</li> <li><code>any</code> - defines a route that matches any HTTP method.</li> <li><code>static</code> - defines a static route that serves a file.</li> <li><code>error</code> - defines an error route that will be executed when an error occurs.</li> </ul> <p>For all the generic routes and the <code>any</code> route you can simply use them as a method of the <code>Router</code> class. For example:</p> <pre><code>&lt;?php\n\n    // index.php file\n\n    // ..... Initialize the App and Router\n\n    Router::get( // Or any other method like post, put, patch, delete, options, head, any\n        path : \"/me/?{name}\",\n        context: [\n            \"name\" =&gt; \"John\"\n        ],\n        exp  : new MyEndpoint( debug: null)\n    );\n</code></pre> <p>This is the same as the previous example but with a more convenient way to define the route.</p> <p><code>static</code> and <code>error</code> routes are special routes that have predefined behavior. The <code>static</code> route will serve a file from the file system and the <code>error</code> route will be executed when an error occurs. The <code>error</code> route is described in the error handling section.</p>"},{"location":"Documentation/routing/#static-routes","title":"Static Routes","text":"<p>Static routes are routes that serve files from the file system. The <code>static</code> route is defined with the <code>static</code> method of the <code>Router</code> class. The <code>static</code> method takes: - <code>path</code> - (string) the path of the route - using the path syntax described below. - <code>directory</code> - (string) the absolute path to the directory that contains the files. - <code>types</code> - (string|array) the file types that will be served. This can be a string or an array of strings. The default is <code>[\"*/*\"]</code> which will serve all files.</p> <p>Here is an example of a static route:</p> <pre><code>&lt;?php\n    // index.php file\n\n    // ..... Initialize the App and Router\n\n    Router::static(\n        path        : \"/storage\", // The path of the route.\n        directory   : __DIR__ . DIRECTORY_SEPARATOR . \"files\", // The directory that contains the files. \n        types       : [\"image/*\", \"text/*\", \"video/*\"] // The types of files that will be served.\n    );\n</code></pre> <p>This will serve files from the <code>files</code> directory when the path <code>/storage/...</code> is requested. The files will be served with the correct mime type based on the file extension.</p> How do I set the file disposition? <p>By default, the file disposition is set to <code>inline</code>. This means that the file will be displayed in the browser. Which means that if the browser can display the file it will. If you want to force the download of the file you can set the file disposition to <code>attachment</code>. This can be done by passing the <code>types</code> parameter as an associative array where the key is the mime type and the value is the file disposition. For example:</p> <pre><code>&lt;?php\n   // ....\n   types : [\n       \"image/*\" =&gt; \"inline\",\n       \"text/*\"  =&gt; \"attachment\",\n       \"video/*\" =&gt; \"inline\"\n   ]\n   // ....\n</code></pre> <p>Note</p> <ol> <li>You can use the path syntax described below to define the path of the static route. But the path should not contain <code>path parameters</code>.</li> <li>All the logic of the static route is handled by a custom handler that is provided by Frigate. This <code>Endpoint</code> is called <code>StaticEndpoint</code> and is described in the endpoints section.</li> </ol>"},{"location":"Documentation/routing/#auto-loading-routes","title":"Auto loading routes","text":"<p>When the application grows, the number of routes will grow as well. To make the code more readable and maintainable, the routes can be defined in separate files and auto-loaded by the router. This can be done by defining the routes in a separate file and then loading the file with the <code>defineFrom</code> method of the <code>Router</code> class. The <code>defineFrom</code> method takes: - <code>path</code> - (string) the path to the folder that contains the route files.</p> <p>Each route file should define a single class that extends the <code>DefineRoute</code> class. The class should have a single constructor that takes no arguments and should define the routes in the constructor. </p> <p>Here is an example of a route file:</p> <pre><code>&lt;?php\n\n// MyNameRoute.php file in the routes folder - /routes/MyNameRoute.php\n\nuse Frigate\\Routing\\Routes\\DefineRoute;\nuse Frigate\\Routing\\Http\\Methods;\nuse Frigate\\Routing\\Http\\ResponseInterface;\nuse Frigate\\Routing\\Http\\RequestInterface;\n\nclass MyNameRoute extends DefineRoute\n{\n    public function __construct()\n    {\n        // Define the route method(s):\n        $this-&gt;method = [Methods::GET, Methods::POST];\n\n        // Define the route path:\n        $this-&gt;path = \"/say/?{name:string}\";\n\n        // Define the route context:\n        $this-&gt;context = [\n            \"name\" =&gt; \"John Doe\"\n        ];\n\n        // Define the supported return types:\n        $this-&gt;returns = [\n            \"application/json\"\n        ];\n\n        // Bind the route endpoint or expression:\n        $this-&gt;exp = function(array $context, RequestInterface $request, ResponseInterface $response) {\n            // Set the response data:\n            $response-&gt;setBodyJson([\n                \"message\"   =&gt; \"success\",\n                \"name\"      =&gt; $context[\"name\"],\n                \"context\"   =&gt; $context\n            ]);\n            // return the response:\n            return $response;\n        };\n\n        // Define the route additional middleware:\n        $this-&gt;middleware = [];\n\n        // Define the route middleware to avoid:\n        $this-&gt;avoid_middleware = [];\n\n        // Define the request mutator:\n        $this-&gt;request_mutator = null;\n    }\n}\n</code></pre> <p>Note</p> <ol> <li>The class name should be the same as the file name without the <code>.php</code> extension.</li> </ol> <p>This is how all the route files inside the routes will be auto-loaded by the router:</p> <pre><code>&lt;?php\n\n// index.php file\n\n// ..... Initialize the App and Router\n\nRouter::defineFrom(\"routes\"); // The path is relative so for a full path use __DIR__ . DIRECTORY_SEPARATOR . \"routes\"\n\n// After this line all the routes defined in the routes folder will be loaded an registered with the router.\n</code></pre>"},{"location":"Documentation/routing/#path-syntax","title":"Path Syntax","text":"<p>The route path is the URI that the router will match against. The route path can contain path parameters, and path parameters can have a type:</p> <ul> <li><code>\"/\"</code> - will match the root path.</li> <li><code>\"users\"</code> - will match the path \"/users\"</li> <li><code>\"users/{id}\"</code> - will match the path \"/users/1\" and \"/users/2\" etc...</li> <li><code>\"users/{id:int}\"</code> - will match the path \"/users/1\" and \"/users/2\" and will place the id in the context as an integer.</li> </ul> <p>Note</p> <ol> <li>The path is case insensitive. This means that the path <code>/users</code> will match <code>/Users</code> and <code>/USERS</code> etc...</li> <li>When defining the same path with the same method twice, the last definition will override the previous one.</li> </ol>"},{"location":"Documentation/routing/#path-parameters","title":"Path parameters","text":"<p>Path parameters are defined by wrapping the parameter name with curly brackets <code>{}</code>. The parameter name can be any alphanumeric string and can contain underscores <code>_</code>. It is recommended to use a descriptive name.</p> <p>The parameter name can also contain a type. The type is used to convert the path parameter to a specific type in the context.</p> <ul> <li><code>int, integer</code> - will convert to an integer.</li> <li><code>float, double</code> - will convert to a float.</li> <li> <p><code>bool, boolean</code> - will convert to a boolean. (1)</p> <ol> <li>The boolean type will convert the following values to true: <code>1, true, on, yes</code> and the following values to false: <code>0, false, off, no</code>.</li> </ol> </li> <li> <p><code>string, str</code> - will match any string. Which is the default type.</p> </li> <li><code>path</code> - will be a string containing the rest of the path.</li> </ul> <p>The way we define the type is by adding a colon <code>:</code> after the parameter name and then the type name:</p> <ul> <li><code>\"users/{id:int}\"</code> - id will be an <code>int</code>.</li> <li><code>\"users/{height:float}\"</code> - height will be a <code>float</code>.</li> <li><code>\"users/{is_active:bool}\"</code> - is_active will be a <code>bool</code>.</li> <li><code>\"users/{name}\"</code> - name will be a <code>string</code>.</li> <li><code>\"users/{name:string}/{id:int}/{action}\"</code> - we can mix types and non types.</li> <li><code>\"users/{storage:path}\"</code> - storage will be a <code>string</code> containing the rest of the path.</li> </ul> Exceptions and limitations <ol> <li>An exception will be thrown if the several path parameters are defined on the same level.<ul> <li>i.e. defining <code>\"users/{id:int}\"</code> and <code>\"users/{name:string}\"</code> will throw an exception.</li> </ul> </li> <li>The <code>path</code> parameter cannot be extended with other parameters.<ul> <li>i.e. <code>\"users/{storage:path}/{id:int}\"</code> will throw an exception.</li> </ul> </li> </ol>"},{"location":"Documentation/routing/#variation-macro","title":"Variation Macro","text":"<p>In Frigate we can define multiple levels of a path with the variation macro <code>?</code>. The variation macro will expand to a several paths:</p> <ul> <li><code>\"users/storage/?{find}/?{term}\"</code> - will expand to:<ul> <li><code>\"users/storage/\"</code></li> <li><code>\"users/storage/{find}/\"</code></li> <li><code>\"users/storage/{find}/{term}\"</code></li> </ul> </li> </ul> <p>Obviously, this can be done manually but it is a lot easier to use the variation macro. Also, the variation macro can be used to mimic default values in path parameters. For example:</p> <pre><code>&lt;?php\n// ...\n\nRouter::define(Methods::GET, new Route(\"users/storage/?find/?{term}\",\n    context : [\n        \"find\" =&gt; \"all\",\n        \"term\" =&gt; \"avatar.png\",\n    ],\n    // ... rest of the route definition\n));\n</code></pre> <p>All the expanded paths will be matched and the context will be merged with the context defined in the route definition. This behavior will result in 3 paths that points to the same route and have \"default\" values for the <code>find</code> and <code>term</code> parameters.</p> <ul> <li><code>\"users/storage/\"</code> - will have the context: <code>[\"find\" =&gt; \"all\", \"term\" =&gt; \"avatar.png\"]</code></li> <li><code>\"users/storage/picture/\"</code> - will have the context: <code>[\"find\" =&gt; \"picture\", \"term\" =&gt; \"avatar.png\"]</code></li> <li><code>\"users/storage/picture/profie.png\"</code> - will have the context: <code>[\"find\" =&gt; \"picture\", \"term\" =&gt; \"profie.png\"]</code></li> </ul>"},{"location":"Documentation/routing/#default-parameter-values","title":"Default parameter values","text":"<p>Default values are not supported in path parameters. They don't make sense in the context of a path parameter. Some frameworks support default values (sort of) by looking ahead in the path and matching the next path part. This is not supported in Frigate.</p> <p>The best way to handle this is to define several paths that point to the same route and have different levels of path parameters. This can be done easily with the variation macro <code>?</code> as described above.</p> Why not??? <p>The reason for this is that it is not clear what the default value should be. For example, if we have the following path: <code>\"users/{id:int}/{action}\"</code> and we want to set the default value of <code>action</code> to <code>view</code>. What should happen if the path is <code>/users/1</code>? Should the default value be set to <code>view</code> or should the path not match? This is not clear and can lead to unexpected behavior.</p>"},{"location":"Documentation/routing/#shadow-path-markers","title":"Shadow path markers","text":"<p>In Frigate shadow paths are defined by adding a <code>^</code> after the path. Internally, the shadow path marker is used to attach expressions that will be executed when the this marker is reached. For example:</p> <ul> <li><code>\"/users^\"</code> - a any path that starts with <code>/users</code> will invoke the attached expressions before the route is executed.</li> <li><code>\"/users^/{id:int}\"</code> - when executing the route <code>/users/1</code> the attached expressions will be executed before the route is executed, passing the modified context to the route.</li> <li><code>\"/users^/{id:int}^/profile\"</code> - shadow paths can be chained together. when executing the route <code>/users/1/profile</code> the shadow expressions will be executed twice, once for <code>/users/1</code> and once for <code>/users/1/profile</code>.</li> </ul> <p>This mechanism is used to attach middleware to a route. and is described in the middleware section.</p> <p>Note</p> <p>The shadow path marker is not part of the path and will not be matched. It is used to attach expressions to the path.</p> <p>Warning</p> <p>Don't use the shadow path marker unless you know what you are doing. Frigate offers a better way to attach middleware to a route. See the middleware section.</p>"},{"location":"Documentation/setup/","title":"Installation &amp; Setup","text":""},{"location":"Documentation/setup/#prerequisites-dependencies","title":"Prerequisites &amp; Dependencies","text":"<p>Frigate requires PHP 8.1 or higher. It is recommended to use the latest stable version of PHP to ensure you have all the latest security patches and performance improvements. Frigate depends on the following PHP extensions:</p> <ul> <li>mbstring - Multibyte string functions (should be available everywhere)</li> <li>json - JavaScript Object Notation (should be available everywhere)</li> </ul> <p>Beside core PHP extensions, Frigate also depends on the following PHP libraries, which are dependencies managed by Composer automatically:</p> <ul> <li>guzzlehttp/guzzle Used for making HTTP requests.</li> <li>sabre/uri Functions for making sense out of URIs.</li> <li>vlucas/phpdotenv PHP dotenv loads environment variables from <code>.env</code> to <code>getenv()</code>, <code>$_ENV</code> and <code>$_SERVER</code> automagically.</li> <li>twig/twig Twig, the flexible, fast, and secure template language for PHP.</li> <li>firebase/php-jwt A simple library to encode and decode JSON Web Tokens (JWT) in PHP.</li> </ul> <p>Note</p> <p>Frigate aims to be lightweight and minimalistic. That's why we are doing our best to keep the number of dependencies as low as possible and only use the most essential and stable libraries.</p>"},{"location":"Documentation/setup/#installation","title":"Installation","text":"<p>Install Frigate with composer:</p> <pre><code>composer require siktec/frigate\n</code></pre>"},{"location":"Documentation/setup/#create-a-project","title":"Create a project","text":"<p>You may want to start with a bootstrap project to get started:</p> <pre><code>composer create-project siktec/frigate-bootstrap\n</code></pre>"},{"location":"Documentation/setup/#project-structure","title":"Project Structure","text":"<p>Frigate is designed to be simple and flexible. It does not enforce any specific project structure. You are free to organize your project however you want. However, we recommend the following project structure (which is also used in the Frigate Bootstrap project):</p> <pre><code>\u251c\u2500\u2500 root\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 api # API endpoints goes here (PSR-4)\n\u2502   \u251c\u2500\u2500 routes # Routes goes here (PSR-4)\n\u2502   \u251c\u2500\u2500 models # Models goes here (PSR-4)\n\u2502   \u251c\u2500\u2500 static # Static files goes here\n\u2502   \u251c\u2500\u2500 pages # Front-end stuff goes here (PSR-4)\n\u2502   \u251c\u2500\u2500 cli # CLI files goes here (PSR-4)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 index.php # Entry point\n\u2502   \u251c\u2500\u2500 .env # Environment variables goes here\n\u2502   \u251c\u2500\u2500 .htaccess # Apache configuration file (optional)\n\u2502   \u251c\u2500\u2500 composer.json # Composer configuration file\n</code></pre>"},{"location":"Documentation/setup/#setting-up-the-server","title":"Setting up the server","text":"<p>Frigate is designed to run on Apache and Nginx web servers. It is recommended to use the latest stable version of Apache or Nginx to ensure you have all the latest security patches and performance improvements.</p> <p>No matter which web server you are using you will need to make sure that any requests to your Frigate application are sent to the <code>index.php</code> file. This is called \"routing\" and is configured differently depending on which web server you are using. For more information on configuring your web server, see the official Apache or Nginx documentation.</p>"},{"location":"Documentation/setup/#apache","title":"Apache","text":"<p>When using Apache, you need to make sure that the <code>mod_rewrite</code> module is enabled. This can be done by running the following command:</p> <pre><code># Enable mod_rewrite\nsudo a2enmod rewrite\n\n# Restart Apache to apply changes\nsudo service apache2 restart\n</code></pre> <p>If you are using Apache, you can use the following <code>.htaccess</code> file in the root of your project to route all requests to the <code>index.php</code> file. Besides routing, this <code>.htaccess</code> file also disables directory browsing and hides all environment files.</p> <pre><code># Disable directory browsing\nOptions -Indexes\n\n# Hide all environment files\n&lt;Files .env&gt;\n    Order allow,deny\n    Deny from all\n&lt;/Files&gt;\n\n&lt;IfModule mod_rewrite.c&gt;\n\n    RewriteEngine On \n\n    # allow HTTP basic authentication (1)\n    RewriteCond %{HTTP:Authorization} ^(.+)$\n    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n\n    # Optional: Set the base path to the public folder\n    # RewriteBase / \n    RewriteRule . index.php [QSA,L]\n\n&lt;/IfModule&gt;\n</code></pre> <ol> <li>This is required if you are using HTTP Basic Authentication. Without this, the <code>Authorization</code> header will not be available to Frigate. Its mainly for Development and Testing purposes; so unless you are using HTTP Basic Authentication for production, comment out these lines.</li> </ol> <p>Info</p> <p>If you created your project using the Frigate Bootstrap project, this <code>.htaccess</code> file is already included in your project.</p> <p>Once you have created your <code>.htaccess</code> file, you need to make sure that your Apache virtual host is configured with the <code>AllowOverride</code> option. This will allow your <code>.htaccess</code> file to override the default settings of your Apache virtual host. You can do this by editing your virtual host configuration file and changing the <code>AllowOverride</code> option from <code>None</code> to <code>All</code>:</p> <pre><code>sudo nano /etc/apache2/sites-available/000-default.conf\n</code></pre> <p>Inside the <code>&lt;VirtualHost *:80&gt;</code> block, change the <code>AllowOverride</code> option to <code>All</code>:</p> <pre><code>&lt;VirtualHost *:80&gt;\n    &lt;Directory /var/www/html&gt;\n        Options Indexes FollowSymLinks\n        AllowOverride All\n        Require all granted\n    &lt;/Directory&gt;\n\n    . . .\n&lt;/VirtualHost&gt;\n</code></pre> <p>Then restart Apache to apply changes:</p> <pre><code>sudo service apache2 restart\n</code></pre> <p>If everything is configured correctly, any requests to your Frigate application should now be routed to the <code>index.php</code> file.</p> Performance Considerations <p><code>.htaccess</code> files and <code>mod_rewrite</code> are sometimes considered as a performance issue. When using <code>.htaccess</code> files every request to your application will be checked for the existence of a <code>.htaccess</code> file in every part of the directory tree. This means that several \"additional\" filesystem accesses are required for every request.</p> <p>In our case, we are using a single <code>.htaccess</code> file in the root of our project. The rule will terminate immediately for any request <code>[QSA,L]</code>. This should minimize the performance impact of using <code>.htaccess</code> files. However, if you are concerned about performance, you can disable <code>.htaccess</code> files and move the rules to your virtual host configuration file. This will reduce the number of filesystem accesses required for every request. see the mod_rewrite documentation for more information.</p> <p>The reason we are using <code>.htaccess</code> is that most shared hosting providers do not allow you to edit the virtual host configuration file. <code>.htaccess</code> files are the only way to configure your application in this case. It is also the easiest way to configure your application and add additional rules that may be required for your application to work correctly.</p>"},{"location":"Documentation/setup/#nginx","title":"Nginx","text":"<p>When using Nginx, you need to make sure that the <code>try_files</code> directive is configured correctly. This can be done by editing your Nginx configuration file, the goal is to make sure that any requests to your Frigate application are routed to the <code>index.php</code> file.</p> <p>Nginx does not support <code>.htaccess</code> files, so you need to make sure that your Nginx configuration file is configured correctly. If you are using Nginx, you need to adjust the configuration file to include the following <code>location</code> block, This will route all requests to the <code>index.php</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n\n    index index.php index.html index.htm index.nginx-debian.html;\n\n    server_name example.com www.example.com;\n\n    # Block access to environment files (just in case)\n    location ~ /\\.env { \n        deny all;\n    }\n\n    # Route all requests to index.php \n    location / {\n        try_files /index.php?$query_string;\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock;\n    }\n\n    # deny access to .htaccess, .htpasswd.\n    location ~ /\\.ht {\n        deny all;\n    }\n}\n</code></pre> <p>Nginx configuration file location</p> <p>The configuration file by default is located at <code>/etc/nginx/sites-available/default</code> or <code>/etc/nginx/nginx.conf</code> depending on your setup.</p>"}]}